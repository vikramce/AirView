var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { Entity, ConstantPositionProperty, ConstantProperty, ReferenceFrame, Cartesian3, Matrix3, Matrix4, CesiumMath, Quaternion, Transforms, JulianDate, PerspectiveFrustum, defined } from './cesium/cesium-imports';
import { autoinject } from 'aurelia-dependency-injection';
import { ContextService, ContextServiceProvider } from './context';
import { SessionService } from './session';
import { AVERAGE_EYE_HEIGHT, DEFAULT_NEAR_PLANE, DEFAULT_FAR_PLANE, Viewport, SerializedSubviewList, SubviewType } from './common';
import { Event, getEntityPositionInReferenceFrame, 
// getEntityOrientationInReferenceFrame,
getSerializedEntityState, requestAnimationFrame, cancelAnimationFrame, } from './utils';
import { ViewService } from './view';
var DeviceState = (function () {
    function DeviceState() {
        this.entities = {};
        this.suggestedUserHeight = AVERAGE_EYE_HEIGHT;
        this.geolocationDesired = false;
        this.geolocationOptions = {};
        this.isPresentingHMD = false;
        this.strict = false;
    }
    return DeviceState;
}());
export { DeviceState };
var DeviceFrameState = (function (_super) {
    __extends(DeviceFrameState, _super);
    function DeviceFrameState() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._scratchFrustum = new PerspectiveFrustum();
        _this.screenOrientationDegrees = 0;
        _this.time = JulianDate.now();
        _this.viewport = { x: 0, y: 0, width: 0, height: 0 };
        _this.subviews = [{
                type: SubviewType.SINGULAR,
                pose: null,
                viewport: { x: 0, y: 0, width: 0, height: 0 },
                projectionMatrix: (_this._scratchFrustum.near = DEFAULT_NEAR_PLANE,
                    _this._scratchFrustum.far = DEFAULT_FAR_PLANE,
                    _this._scratchFrustum.fov = CesiumMath.PI_OVER_THREE,
                    _this._scratchFrustum.aspectRatio = 1,
                    Matrix4.clone(_this._scratchFrustum.projectionMatrix))
            }];
        return _this;
    }
    return DeviceFrameState;
}(DeviceState));
export { DeviceFrameState };
;
var DeviceService = (function () {
    function DeviceService(sessionService, contextService, viewService) {
        var _this = this;
        this.sessionService = sessionService;
        this.contextService = contextService;
        this.viewService = viewService;
        this.autoSubmitFrame = true;
        this.deviceState = new DeviceState;
        this.frameState = new DeviceFrameState;
        this.frameStateEvent = new Event();
        /**
         * An entity representing the physical floor-level plane below the user,
         * where +X is east, +Y is North, and +Z is up (if geolocation is known)
         */
        this.stage = this.contextService.entities.add(new Entity({
            id: 'ar.device.stage',
            name: 'Device Stage',
            position: undefined,
            orientation: undefined
        }));
        /**
         * An entity representing the physical pose of the user,
         * where +X is right, +Y is up, and -Z is forward
         */
        this.user = this.contextService.entities.add(new Entity({
            id: 'ar.device.user',
            name: 'Device User',
            position: undefined,
            orientation: undefined
        }));
        this._getEntityPositionInReferenceFrame = getEntityPositionInReferenceFrame;
        // private _getEntityOrientationInReferenceFrame = getEntityOrientationInReferenceFrame;
        this._scratchCartesian = new Cartesian3;
        this._scratchCartesian2 = new Cartesian3;
        this._scratchFrustum = new PerspectiveFrustum();
        this._updating = false;
        this._updateFrameState = function () {
            if (!_this._updating)
                return;
            var state = _this.frameState = _this.frameState || {};
            var time = state.time = JulianDate.now(state.time);
            state.screenOrientationDegrees = _this.getScreenOrientationDegrees();
            _this.onUpdateFrameState();
            var contextViewId = _this.contextService.view.id;
            for (var i = 0; i < state.subviews.length; i++) {
                var s = state.subviews[i];
                s.pose = _this._getSerializedEntityState(_this.getSubviewEntity(i), time, _this.user);
                if (s.pose)
                    s.pose.r = contextViewId;
            }
            _this.frameStateEvent.raiseEvent(state);
            _this.requestAnimationFrame(_this._updateFrameState);
        };
        /**
         * Request an animation frame callback for the current view.
         */
        this.requestAnimationFrame = function (callback) {
            if (currentVRDisplay) {
                return currentVRDisplay.requestAnimationFrame(callback);
            }
            else {
                return requestAnimationFrame(callback);
            }
        };
        this.cancelAnimationFrame = function (id) {
            if (currentVRDisplay) {
                return currentVRDisplay.cancelAnimationFrame(id);
            }
            else {
                return cancelAnimationFrame(id);
            }
        };
        this._scratchQuaternion = new Quaternion;
        this._scratchQuaternion2 = new Quaternion;
        this._scratchMatrix3 = new Matrix3;
        this._scratchMatrix4 = new Matrix4;
        this._stageEUS = new Entity({
            position: new ConstantPositionProperty(Cartesian3.ZERO, this.stage),
            orientation: new ConstantProperty(Quaternion.fromAxisAngle(Cartesian3.UNIT_X, CesiumMath.PI_OVER_TWO))
        });
        /**
         * Defines the webvr standing space, positioned at the stage (EUS) frame by default.
         */
        this.vrStandingSpace = new Entity({
            position: new ConstantPositionProperty(Cartesian3.ZERO, this._stageEUS),
            orientation: new ConstantProperty(Quaternion.IDENTITY)
        });
        this._scratchFrameState = {
            time: {},
            entities: {},
            viewport: {},
            subviews: []
        };
        this._getSerializedEntityState = getSerializedEntityState;
        sessionService.manager.on['ar.device.state'] =
            sessionService.manager.on['ar.device.frameState'] = this._onDeviceState.bind(this);
        contextService.frameStateEvent.addEventListener(function (state) {
            var time = state.time;
            var contextService = _this.contextService;
            var entities = state.entities;
            // stage
            var deviceStage = _this.stage;
            var contextStage = contextService.stage;
            if (entities[contextStage.id] === undefined) {
                var contextStagePosition = contextStage.position;
                var contextStageOrientation = contextStage.orientation;
                contextStagePosition.setValue(Cartesian3.ZERO, deviceStage);
                contextStageOrientation.setValue(Quaternion.IDENTITY);
            }
            // user
            var deviceUser = _this.user;
            var contextUser = contextService.user;
            if (entities[contextUser.id] === undefined) {
                var deviceUserPosition = deviceUser.position;
                var deviceUserOrientation = deviceUser.orientation;
                var userPositionValue = deviceUserPosition && deviceUserPosition.getValueInReferenceFrame(time, deviceStage, _this._scratchCartesian);
                var userOrientationValue = deviceUserOrientation && deviceUserOrientation.getValue(time, _this._scratchQuaternion);
                var contextUserPosition = contextUser.position;
                var contextUserOrientation = contextUser.orientation;
                contextUserPosition.setValue(userPositionValue, contextStage);
                contextUserOrientation.setValue(userOrientationValue);
            }
            // view
            var contextView = contextService.view;
            if (entities[contextView.id] === undefined) {
                var contextViewPosition = contextView.position;
                var contextViewOrientation = contextView.orientation;
                contextViewPosition.setValue(Cartesian3.ZERO, contextUser);
                contextViewOrientation.setValue(Quaternion.IDENTITY);
            }
            // floor
            if (entities[contextService.floor.id] === undefined) {
                var floorPosition = contextService.floor.position;
                floorPosition.setValue(Cartesian3.ZERO, contextStage);
            }
            // If running within an older manager, we have to set the stage based on the user pose. 
            if (_this.sessionService.manager.isConnected && _this.sessionService.manager.version[0] === 0) {
                var userPositionFixed = _this._getEntityPositionInReferenceFrame(contextUser, time, ReferenceFrame.FIXED, _this._scratchCartesian);
                if (userPositionFixed) {
                    var enuToFixedFrameTransform = Transforms.eastNorthUpToFixedFrame(userPositionFixed, undefined, _this._scratchMatrix4);
                    var enuRotationMatrix = Matrix4.getRotation(enuToFixedFrameTransform, _this._scratchMatrix3);
                    var enuOrientation = Quaternion.fromRotationMatrix(enuRotationMatrix);
                    contextStage.position.setValue(userPositionFixed, ReferenceFrame.FIXED);
                    contextStage.orientation.setValue(enuOrientation);
                }
            }
        });
        // if (this.sessionService.isRealityManager || this.sessionService.isRealityViewer) {
        //     this.sessionService.manager.connectEvent.addEventListener(()=>{
        //         this.startUpdates();
        //     });
        // }
        this.startUpdates();
        this.sessionService.manager.closeEvent.addEventListener(function () {
            _this.stopUpdates();
        });
        this._setupVRPresentChangeHandler();
    }
    Object.defineProperty(DeviceService.prototype, "geoHeadingAccuracy", {
        get: function () {
            return this.user['meta'] ? this.user['meta'].geoHeadingAccuracy : undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DeviceService.prototype, "geoHorizontalAccuracy", {
        get: function () {
            return this.stage['meta'] ? this.stage['meta'].geoHorizonatalAccuracy : undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DeviceService.prototype, "geoVerticalAccuracy", {
        get: function () {
            return this.stage['meta'] ? this.stage['meta'].geoVerticalAccuracy : undefined;
        },
        enumerable: true,
        configurable: true
    });
    DeviceService.prototype._onDeviceState = function (deviceState) {
        this.deviceState = deviceState;
        this.frameState.suggestedUserHeight = deviceState.suggestedUserHeight;
        this.frameState.isPresentingHMD = deviceState.isPresentingHMD;
        this.frameState.geolocationDesired = deviceState.geolocationDesired;
        this.frameState.geolocationOptions = deviceState.geolocationOptions;
        var entities = deviceState.entities;
        var contextService = this.contextService;
        if (entities)
            for (var id in entities) {
                contextService.updateEntityFromSerializedState(id, entities[id]);
            }
    };
    DeviceService.prototype.getScreenOrientationDegrees = function () {
        return typeof window !== 'undefined' ? (screen['orientation'] && -screen['orientation'].angle) || -window.orientation || 0 : 0;
    };
    /**
     * Start emmitting frameState events
     */
    DeviceService.prototype.startUpdates = function () {
        var _this = this;
        if (!this._updating)
            this.requestAnimationFrame(this._updateFrameState);
        this._updating = true;
        this.sessionService.manager.whenConnected().then(function () {
            if (_this.sessionService.manager.version[0] > 0) {
                _this.sessionService.manager.send('ar.device.startUpdates');
            }
        });
    };
    /**
     * Stop emitting frameState events
     */
    DeviceService.prototype.stopUpdates = function () {
        var _this = this;
        this._updating = false;
        this.sessionService.manager.whenConnected().then(function () {
            if (_this.sessionService.manager.version[0] > 0) {
                _this.sessionService.manager.send('ar.device.stopUpdates');
            }
        });
    };
    DeviceService.prototype.onUpdateFrameState = function () {
        if (currentVRDisplay) {
            this._updateForWebVR();
        }
        else {
            this._updateDefault();
        }
    };
    DeviceService.prototype._updateDefault = function () {
        this._updateUserDefault();
        var frameState = this.frameState;
        var deviceState = this.deviceState;
        var element = this.viewService.element;
        var viewport = frameState.viewport;
        if (deviceState.viewport) {
            Viewport.clone(deviceState.viewport, viewport);
        }
        else {
            viewport.x = 0;
            viewport.y = 0;
            viewport.width = element && element.clientWidth || 0;
            viewport.height = element && element.clientHeight || 0;
        }
        var subviews = frameState.subviews;
        if (deviceState.subviews) {
            SerializedSubviewList.clone(deviceState.subviews, subviews);
        }
        else {
            subviews.length = 1;
            var subview = subviews[0] || {};
            subview.type = SubviewType.SINGULAR;
            subview.viewport.x = 0;
            subview.viewport.y = 0;
            subview.viewport.width = viewport.width;
            subview.viewport.height = viewport.height;
            var aspect = viewport.width / viewport.height;
            var frustum = this._scratchFrustum;
            frustum.near = DEFAULT_NEAR_PLANE;
            frustum.far = DEFAULT_FAR_PLANE;
            frustum.fov = CesiumMath.PI_OVER_THREE;
            frustum.aspectRatio = isFinite(aspect) && aspect !== 0 ? aspect : 1;
            subview.projectionMatrix = Matrix4.clone(frustum.projectionMatrix, subview.projectionMatrix);
            var subviewEntity = this.getSubviewEntity(0);
            subviewEntity.position.setValue(Cartesian3.ZERO, this.user);
            subviewEntity.orientation.setValue(Quaternion.IDENTITY);
        }
    };
    DeviceService.prototype._updateForWebVR = function () {
        var frameState = this.frameState;
        var vrDisplay = currentVRDisplay;
        var element = this.viewService.element;
        var viewport = frameState.viewport;
        viewport.x = 0;
        viewport.y = 0;
        viewport.width = element && element.clientWidth || 0;
        viewport.height = element && element.clientHeight || 0;
        var vrFrameData = this._vrFrameData =
            this._vrFrameData || new VRFrameData();
        if (!vrDisplay['getFrameData'](vrFrameData))
            return this.frameState;
        var layers = vrDisplay.getLayers();
        var leftBounds = layers[0].leftBounds;
        var rightBounds = layers[0].rightBounds;
        var subviews = frameState.subviews = frameState.subviews || [];
        subviews.length = 2;
        var leftSubview = subviews[0] = subviews[0] || {};
        var rightSubview = subviews[1] = subviews[1] || {};
        leftSubview.type = SubviewType.LEFTEYE;
        rightSubview.type = SubviewType.RIGHTEYE;
        var leftViewport = leftSubview.viewport = leftSubview.viewport || {};
        leftViewport.x = leftBounds[0] * viewport.width;
        leftViewport.y = leftBounds[1] * viewport.height;
        leftViewport.width = leftBounds[2] * viewport.width;
        leftViewport.height = leftBounds[3] * viewport.height;
        var rightViewport = rightSubview.viewport = rightSubview.viewport || {};
        rightViewport.x = rightBounds[0] * viewport.width;
        rightViewport.y = rightBounds[1] * viewport.height;
        rightViewport.width = rightBounds[2] * viewport.width;
        rightViewport.height = rightBounds[3] * viewport.height;
        leftSubview.projectionMatrix = Matrix4.clone(vrFrameData.leftProjectionMatrix, leftSubview.projectionMatrix);
        rightSubview.projectionMatrix = Matrix4.clone(vrFrameData.rightProjectionMatrix, rightSubview.projectionMatrix);
        var sittingToStandingTransform = vrDisplay.stageParameters ?
            vrDisplay.stageParameters.sittingToStandingTransform :
            Matrix4.IDENTITY;
        var sittingToStandingRotation = Matrix4.getRotation(sittingToStandingTransform, this._scratchMatrix3);
        var sittingToStandingQuaternion = Quaternion.fromRotationMatrix(sittingToStandingRotation, this._scratchQuaternion);
        var user = this.user;
        var standingSpace = this.vrStandingSpace;
        var sittingUserPosition = vrFrameData.pose.position ?
            Cartesian3.unpack(vrFrameData.pose.position, 0, this._scratchCartesian) : undefined;
        var standingUserPosition = sittingUserPosition ?
            Matrix4.multiplyByPoint(sittingToStandingTransform, sittingUserPosition, this._scratchCartesian) : undefined;
        var sittingUserOrientation = vrFrameData.pose.orientation ?
            Quaternion.unpack(vrFrameData.pose.orientation, 0, this._scratchQuaternion2) : undefined;
        var standingUserOrientation = sittingUserOrientation ?
            Quaternion.multiply(sittingToStandingQuaternion, sittingUserOrientation, this._scratchQuaternion) : undefined;
        user.position.setValue(standingUserPosition, standingSpace);
        user.orientation.setValue(standingUserOrientation);
        if (standingUserPosition && standingUserOrientation) {
            var leftEyeSittingSpaceTransform = Matrix4.inverseTransformation(vrFrameData.leftViewMatrix, this._scratchMatrix4);
            var leftEyeStandingSpaceTransform = Matrix4.multiplyTransformation(sittingToStandingTransform, leftEyeSittingSpaceTransform, this._scratchMatrix4);
            var leftEye = this.getSubviewEntity(0);
            var leftEyePosition = Matrix4.getTranslation(leftEyeStandingSpaceTransform, this._scratchCartesian);
            var leftEyeRotation = Matrix4.getRotation(leftEyeStandingSpaceTransform, this._scratchMatrix3);
            var leftEyeOrientation = Quaternion.fromRotationMatrix(leftEyeRotation, this._scratchQuaternion);
            leftEye.position.setValue(leftEyePosition, standingSpace);
            leftEye.orientation.setValue(leftEyeOrientation);
            var rightEyeSittingSpaceTransform = Matrix4.inverseTransformation(vrFrameData.rightViewMatrix, this._scratchMatrix4);
            var rightEyeStandingSpaceTransform = Matrix4.multiplyTransformation(sittingToStandingTransform, rightEyeSittingSpaceTransform, this._scratchMatrix4);
            var rightEye = this.getSubviewEntity(1);
            var rightEyePosition = Matrix4.getTranslation(rightEyeStandingSpaceTransform, this._scratchCartesian);
            var rightEyeRotation = Matrix4.getRotation(rightEyeStandingSpaceTransform, this._scratchMatrix3);
            var rightEyeOrientation = Quaternion.fromRotationMatrix(rightEyeRotation, this._scratchQuaternion);
            rightEye.position.setValue(rightEyePosition, standingSpace);
            rightEye.orientation.setValue(rightEyeOrientation);
        }
        if (vrDisplay.displayName.match(/polyfill/g)) {
            // The polyfill does not support reporting an absolute orientation (yet), 
            // so fall back to the default orientation calculation
            user.position.setValue(undefined, undefined);
            user.orientation.setValue(undefined);
            this._updateUserDefault();
        }
    };
    /**
     * Generate a frame state for the ContextService.
     *
     * @param time
     * @param viewport
     * @param subviewList
     * @param user
     * @param entityOptions
     */
    DeviceService.prototype.createContextFrameState = function (time, viewport, subviewList, options) {
        // TODO: In certain cases (webvr?), we may want to disallow the reality from overriding the user entity 
        for (var _i = 0, subviewList_1 = subviewList; _i < subviewList_1.length; _i++) {
            var s = subviewList_1[_i];
            if (!isFinite(s.projectionMatrix[0]))
                throw new Error('Invalid projection matrix (contains non-finite values)');
        }
        var frameState = this._scratchFrameState;
        frameState.time = JulianDate.clone(time, frameState.time);
        frameState.viewport = Viewport.clone(viewport, frameState.viewport);
        frameState.subviews = SerializedSubviewList.clone(subviewList, frameState.subviews);
        var contextService = this.contextService;
        var getEntityState = this._getSerializedEntityState;
        // stage
        var stage = contextService.stage;
        if (options && options.overrideStage) {
            frameState.entities[stage.id] = getEntityState(stage, time, undefined);
        }
        else {
            delete frameState.entities[stage.id];
        }
        // user
        var user = contextService.user;
        if (options && options.overrideUser) {
            frameState.entities[user.id] = getEntityState(user, time, stage);
        }
        else {
            delete frameState.entities[user.id];
        }
        // view
        var view = contextService.view;
        if (options && options.overrideView) {
            frameState.entities[view.id] = getEntityState(view, time, user);
        }
        else {
            delete frameState.entities[view.id];
        }
        // floor
        var floorOffset = options && options.floorOffset || 0;
        var floor = this.contextService.floor;
        floor.position.setValue(Cartesian3.fromElements(0, 0, floorOffset, this._scratchCartesian), stage);
        if (floorOffset !== 0) {
            frameState.entities[contextService.floor.id] = getEntityState(floor, time, stage);
        }
        return frameState;
    };
    DeviceService.prototype.getSubviewEntity = function (index) {
        var subviewEntity = this.contextService.entities.getOrCreateEntity('ar.device.view_' + index);
        if (!subviewEntity.position) {
            subviewEntity.position = new ConstantPositionProperty();
        }
        if (!subviewEntity.orientation) {
            subviewEntity.orientation = new ConstantProperty();
        }
        return subviewEntity;
    };
    DeviceService.prototype.subscribeGeolocation = function (options, session) {
        if (session === void 0) { session = this.sessionService.manager; }
        if (session.version[0] > 0)
            session.send('ar.device.setGeolocationOptions', { options: options });
        return this.contextService.subscribe(this.stage.id, session).then(function () { });
    };
    DeviceService.prototype.unsubscribeGeolocation = function (session) {
        if (session === void 0) { session = this.sessionService.manager; }
        this.contextService.unsubscribe(this.stage.id, session);
    };
    Object.defineProperty(DeviceService.prototype, "isPresentingHMD", {
        get: function () {
            return this.frameState.isPresentingHMD;
        },
        enumerable: true,
        configurable: true
    });
    DeviceService.prototype.requestPresentHMD = function () {
        var _this = this;
        return this.sessionService.manager.request('ar.device.requestPresentHMD').then(function () {
            _this.frameState.isPresentingHMD = true;
        });
    };
    DeviceService.prototype.exitPresentHMD = function () {
        var _this = this;
        return this.sessionService.manager.request('ar.device.exitPresentHMD').then(function () {
            _this.frameState.isPresentingHMD = false;
        });
    };
    DeviceService.prototype._updateUserDefault = function () {
        var deviceUser = this.user;
        var deviceStage = this.stage;
        var deviceOrientation = this._deviceOrientation;
        this._tryOrientationUpdates();
        if (!deviceOrientation) {
            deviceUser.position = undefined;
            deviceUser.orientation = undefined;
            return;
        }
        var screenOrientation = Quaternion.fromAxisAngle(Cartesian3.UNIT_Z, this.frameState.screenOrientationDegrees * CesiumMath.RADIANS_PER_DEGREE, this._scratchQuaternion);
        if (!deviceUser.position)
            deviceUser.position = new ConstantPositionProperty();
        if (!deviceUser.orientation)
            deviceUser.orientation = new ConstantProperty();
        deviceUser.position.setValue(Cartesian3.fromElements(0, 0, this.deviceState.suggestedUserHeight, this._scratchCartesian), deviceStage);
        deviceUser.orientation.setValue(Quaternion.multiply(deviceOrientation, screenOrientation, this._scratchQuaternion));
        deviceUser['meta'] = deviceUser['meta'] || {};
        deviceUser['meta'].geoHeadingAccuracy = this._deviceOrientationHeadingAccuracy;
    };
    DeviceService.prototype._tryOrientationUpdates = function () {
        var _this = this;
        if (typeof window == 'undefined' || !window.addEventListener)
            return;
        if (defined(this._deviceOrientationListener))
            return;
        var headingDrift = 0;
        var alphaOffset = undefined;
        this._deviceOrientationListener = function (e) {
            var alphaDegrees = e.alpha;
            var webkitCompassHeading = e['webkitCompassHeading'];
            var webkitCompassAccuracy = +e['webkitCompassAccuracy'];
            if (!defined(alphaDegrees)) {
                return;
            }
            if (e.absolute) {
                alphaOffset = 0;
            }
            // when the phone is almost updside down, webkit flips the compass heading 
            // (not documented anywhere, annoyingly)
            // if (e.beta >= 130 || e.beta <= -130) webkitCompassHeading = undefined;
            _this._deviceOrientationHeadingAccuracy = webkitCompassAccuracy > 0 ? webkitCompassAccuracy : undefined;
            if ((!defined(alphaOffset) || Math.abs(headingDrift) > 5) &&
                defined(webkitCompassHeading) &&
                webkitCompassAccuracy >= 0 &&
                webkitCompassAccuracy < 80 &&
                webkitCompassHeading >= 0) {
                if (!defined(alphaOffset)) {
                    alphaOffset = -webkitCompassHeading;
                }
                else {
                    alphaOffset -= headingDrift;
                }
            }
            if (!defined(alphaOffset) ||
                !defined(e.alpha) ||
                !defined(e.beta) ||
                !defined(e.gamma))
                return;
            var alpha = CesiumMath.RADIANS_PER_DEGREE * (e.alpha + alphaOffset || -webkitCompassHeading || 0);
            var beta = CesiumMath.RADIANS_PER_DEGREE * e.beta;
            var gamma = CesiumMath.RADIANS_PER_DEGREE * e.gamma;
            var alphaQuat = Quaternion.fromAxisAngle(Cartesian3.UNIT_Z, alpha, _this._scratchQuaternion);
            var betaQuat = Quaternion.fromAxisAngle(Cartesian3.UNIT_X, beta, _this._scratchQuaternion2);
            var alphaBetaQuat = Quaternion.multiply(alphaQuat, betaQuat, _this._scratchQuaternion);
            var gammaQuat = Quaternion.fromAxisAngle(Cartesian3.UNIT_Y, gamma, _this._scratchQuaternion2);
            var alphaBetaGammaQuat = Quaternion.multiply(alphaBetaQuat, gammaQuat, _this._scratchQuaternion);
            _this._deviceOrientation = Quaternion.clone(alphaBetaGammaQuat, _this._deviceOrientation);
            _this._deviceOrientationHeadingAccuracy = webkitCompassAccuracy;
            // TODO: fix heading drift calculation (heading should match webkitCompassHeading)
            // if (defined(webkitCompassHeading)) {
            //     const q = alphaBetaGammaQuat//utils.getEntityOrientationInReferenceFrame(this.interfaceEntity, JulianDate.now(), this.locationEntity, this._scratchQuaternion1);
            //     var heading = -Math.atan2(2*(q.w*q.z + q.x*q.y), 1 - 2*(q.y*q.y + q.z*q.z));
            //     if (heading < 0) heading += 2*Math.PI;
            //     const {swing,twist} = swingTwistDecomposition(alphaBetaGammaQuat, Cartesian3.UNIT_Z);
            //     const twistAngle = 2 * Math.acos(twist.w);
            //     console.log(twist.w + ' ' + twistAngle * CesiumMath.DEGREES_PER_RADIAN + '\n' + webkitCompassHeading);
            //     // this._headingDrift = webkitCompassHeading - heading * CesiumMath.DEGREES_PER_RADIAN;
            // }
        };
        if ('ondeviceorientationabsolute' in window) {
            window.addEventListener('deviceorientationabsolute', this._deviceOrientationListener);
        }
        else if ('ondeviceorientation' in window) {
            window.addEventListener('deviceorientation', this._deviceOrientationListener);
        }
    };
    DeviceService.prototype._setupVRPresentChangeHandler = function () {
        var _this = this;
        if (typeof window !== 'undefined' && window.addEventListener) {
            var currentCanvas_1;
            var previousPresentationMode_1;
            this.contextService.postRenderEvent.addEventListener(function () {
                if (_this.autoSubmitFrame && currentVRDisplay && currentVRDisplay.isPresenting) {
                    currentVRDisplay.submitFrame();
                }
            });
            var handleVRDisplayPresentChange = function (e) {
                var viewService = _this.viewService;
                var vrDisplay = e.display || e.detail.vrdisplay || e.detail.display;
                if (vrDisplay) {
                    var layers = vrDisplay.getLayers();
                    var isThisView = currentVRDisplay === vrDisplay;
                    for (var _i = 0, layers_1 = layers; _i < layers_1.length; _i++) {
                        var layer = layers_1[_i];
                        if (layer.source && viewService.element.contains(layer.source)) {
                            isThisView = true;
                            break;
                        }
                    }
                    if (isThisView) {
                        if (vrDisplay.isPresenting) {
                            currentVRDisplay = vrDisplay;
                            if (vrDisplay.displayName.match(/Cardboard/g)) {
                                currentCanvas_1 = vrDisplay.getLayers()[0].source;
                                if (currentCanvas_1)
                                    currentCanvas_1.classList.add('argon-interactive');
                                previousPresentationMode_1 = viewService.viewportMode;
                                viewService.desiredViewportMode = 1 /* IMMERSIVE */;
                            }
                        }
                        else {
                            currentVRDisplay = undefined;
                            if (currentCanvas_1 && vrDisplay.displayName.match(/Cardboard/g)) {
                                currentCanvas_1.classList.remove('argon-interactive');
                                currentCanvas_1 = undefined;
                                viewService.desiredViewportMode = previousPresentationMode_1;
                            }
                        }
                    }
                }
                viewService.viewportModeChangeEvent.addEventListener(function (mode) {
                    if (mode === 0 /* PAGE */)
                        _this.exitPresentHMD();
                });
            };
            window.addEventListener('vrdisplaypresentchange', handleVRDisplayPresentChange);
        }
    };
    return DeviceService;
}());
DeviceService = __decorate([
    autoinject(),
    __metadata("design:paramtypes", [SessionService,
        ContextService,
        ViewService])
], DeviceService);
export { DeviceService };
var currentVRDisplay;
var DeviceServiceProvider = (function () {
    function DeviceServiceProvider(sessionService, deviceService, contextService, viewService, contextServiceProvider) {
        var _this = this;
        this.sessionService = sessionService;
        this.deviceService = deviceService;
        this.contextService = contextService;
        this.viewService = viewService;
        this.contextServiceProvider = contextServiceProvider;
        this._subscribers = new Set();
        this.defaultUserHeight = AVERAGE_EYE_HEIGHT;
        this._targetGeolocationOptions = {};
        this._sessionGeolocationOptions = new Map();
        this._scratchCartesianLocalOrigin = new Cartesian3;
        this._scratchQuaternionLocalOrigin = new Quaternion;
        this._scratchFrustum = new PerspectiveFrustum();
        this.contextServiceProvider.publishingReferenceFrameMap.set(deviceService.stage.id, ReferenceFrame.FIXED);
        this.contextServiceProvider.publishingReferenceFrameMap.set(deviceService.user.id, deviceService.stage.id);
        this.sessionService.connectEvent.addEventListener(function (session) {
            // backwards compat pre-v1.1.8
            session.on['ar.device.requestFrameState'] = function () {
                _this._subscribers.add(session);
                return new Promise(function (resolve) {
                    var remove = _this.deviceService.frameStateEvent.addEventListener(function (frameState) {
                        resolve(frameState);
                        remove();
                    });
                });
            };
            session.on['ar.device.startUpdates'] = function () {
                _this._subscribers.add(session);
            };
            session.on['ar.device.stopUpdates'] = function () {
                _this._subscribers.delete(session);
            };
            session.on['ar.device.setGeolocationOptions'] = function (options) {
                _this._handleSetGeolocationOptions(session, options);
            };
            session.on['ar.device.requestPresentHMD'] = function () {
                return _this.handleRequestPresentHMD(session).then(function () {
                    _this.deviceService.deviceState.isPresentingHMD = true;
                    _this.publishDeviceState();
                });
            };
            session.on['ar.device.exitPresentHMD'] = function () {
                return _this.handleExitPresentHMD(session).then(function () {
                    _this.deviceService.deviceState.isPresentingHMD = false;
                    _this.publishDeviceState();
                });
            };
        });
        this.contextServiceProvider.subscribersChangeEvent.addEventListener(function (_a) {
            var id = _a.id;
            if (_this.deviceService.stage.id === id || _this.contextService.stage.id === id)
                _this._checkDeviceGeolocationSubscribers();
        });
        if (typeof window !== 'undefined' && window.addEventListener) {
            var orientationChangeListener_1 = function () {
                _this.publishDeviceState();
            };
            window.addEventListener('orientationchange', orientationChangeListener_1);
            sessionService.manager.closeEvent.addEventListener(function () {
                window.removeEventListener('orientationchange', orientationChangeListener_1);
            });
        }
    }
    DeviceServiceProvider.prototype.handleRequestPresentHMD = function (session) {
        var _this = this;
        if (typeof navigator !== 'undefined' &&
            navigator.getVRDisplays) {
            var requestPresent = function (vrDisplay) {
                currentVRDisplay = vrDisplay;
                var element = _this.viewService.element;
                var layers = [];
                layers[0] = { source: element.querySelector('canvas') || element.lastElementChild };
                return vrDisplay.requestPresent(layers).catch(function (e) {
                    currentVRDisplay = undefined;
                    throw e;
                });
            };
            if (navigator.activeVRDisplays && navigator.activeVRDisplays.length) {
                return requestPresent(navigator.activeVRDisplays[0]);
            }
            else {
                return navigator.getVRDisplays()
                    .then(function (displays) { return displays[0]; })
                    .then(requestPresent);
            }
        }
        throw new Error('No HMD available');
    };
    DeviceServiceProvider.prototype.handleExitPresentHMD = function (session) {
        if (currentVRDisplay) {
            var vrDisplay = currentVRDisplay;
            currentVRDisplay = undefined;
            return vrDisplay.exitPresent();
        }
        return Promise.resolve();
    };
    DeviceServiceProvider.prototype.publishDeviceState = function () {
        var _this = this;
        var deviceState = this.deviceService.deviceState;
        deviceState.geolocationDesired = this.contextServiceProvider.geolocationDesired;
        deviceState.geolocationOptions = this.contextServiceProvider.desiredGeolocationOptions;
        deviceState.suggestedUserHeight = this.suggestedUserHeight;
        this.onUpdateDeviceState(this.deviceService.deviceState);
        // send device state to each subscribed session 
        var time = JulianDate.now();
        this._subscribers.forEach(function (s) {
            if (s.version[0] > 0) {
                for (var k in deviceState.entities) {
                    delete deviceState.entities[k];
                }
                ;
                _this.contextServiceProvider.fillEntityStateMapForSession(s, time, deviceState.entities);
                s.send('ar.device.state', deviceState);
            }
        });
    };
    Object.defineProperty(DeviceServiceProvider.prototype, "suggestedUserHeight", {
        get: function () {
            return this.deviceService.isPresentingHMD ? this.defaultUserHeight : this.defaultUserHeight / 2;
        },
        enumerable: true,
        configurable: true
    });
    DeviceServiceProvider.prototype.onUpdateDeviceState = function (deviceState) {
        var _this = this;
        var vrDisplay = currentVRDisplay;
        if (!vrDisplay) {
            deviceState.viewport = undefined;
            deviceState.subviews = undefined;
            deviceState.strict = false;
            return;
        }
        // Since the WebVR polyfill only manages state within one browser window,
        // we will just pass down the viewport/subview configuration in the device state.
        // In managed sessions with real WebVR implementations, the WebVR API is used directly in the DeviceService
        // (this is not really useful within an iframe, since real webVR implementations currently do not support
        // a way to composite content from different iframes, however once WebVR is decoupled from the DOM and can run
        // in a worker, the DeviceService should be able to leverage the WebVR API as needed within each frame)
        var vrFrameData = this._vrFrameData =
            this._vrFrameData || new VRFrameData();
        if (!vrDisplay['getFrameData'](vrFrameData)) {
            setTimeout(function () { return _this.publishDeviceState(); }, 500);
            return;
        }
        var element = this.viewService.element;
        var viewport = deviceState.viewport = deviceState.viewport || {};
        viewport.x = 0;
        viewport.y = 0;
        viewport.width = element && element.clientWidth || 0;
        viewport.height = element && element.clientHeight || 0;
        var layers = vrDisplay.getLayers();
        var leftBounds = layers[0].leftBounds;
        var rightBounds = layers[0].rightBounds;
        var subviews = deviceState.subviews = deviceState.subviews || [];
        subviews.length = 2;
        var leftSubview = subviews[0] = subviews[0] || {};
        var rightSubview = subviews[1] = subviews[1] || {};
        leftSubview.type = SubviewType.LEFTEYE;
        rightSubview.type = SubviewType.RIGHTEYE;
        var leftViewport = leftSubview.viewport = leftSubview.viewport || {};
        leftViewport.x = leftBounds[0] * viewport.width;
        leftViewport.y = leftBounds[1] * viewport.height;
        leftViewport.width = leftBounds[2] * viewport.width;
        leftViewport.height = leftBounds[3] * viewport.height;
        var rightViewport = rightSubview.viewport = rightSubview.viewport || {};
        rightViewport.x = rightBounds[0] * viewport.width;
        rightViewport.y = rightBounds[1] * viewport.height;
        rightViewport.width = rightBounds[2] * viewport.width;
        rightViewport.height = rightBounds[3] * viewport.height;
        leftSubview.projectionMatrix = Matrix4.clone(vrFrameData.leftProjectionMatrix, leftSubview.projectionMatrix);
        rightSubview.projectionMatrix = Matrix4.clone(vrFrameData.rightProjectionMatrix, rightSubview.projectionMatrix);
    };
    DeviceServiceProvider.prototype._checkDeviceGeolocationSubscribers = function () {
        var subscribers = this.contextServiceProvider.subscribersByEntityId.get(this.deviceService.stage.id);
        if (subscribers && subscribers.size > 0) {
            this._updateTargetGeolocationOptions();
            if (JSON.stringify(this._targetGeolocationOptions) !== JSON.stringify(this._currentGeolocationOptions)) {
                this._currentGeolocationOptions = this._targetGeolocationOptions;
                this.onStopGeolocationUpdates();
                this.onStartGeolocationUpdates(this._targetGeolocationOptions);
            }
        }
        else {
            this.onStopGeolocationUpdates();
            this._currentGeolocationOptions = undefined;
        }
        this.publishDeviceState();
    };
    DeviceServiceProvider.prototype._handleSetGeolocationOptions = function (session, options) {
        var _this = this;
        this._sessionGeolocationOptions.set(session, options);
        session.closeEvent.addEventListener(function () {
            _this._sessionGeolocationOptions.delete(session);
        });
    };
    DeviceServiceProvider.prototype._updateTargetGeolocationOptions = function () {
        var reducedOptions = {};
        this._sessionGeolocationOptions.forEach(function (options, session) {
            reducedOptions.enableHighAccuracy =
                reducedOptions.enableHighAccuracy || (options && options.enableHighAccuracy) || false;
        });
        if (this._targetGeolocationOptions.enableHighAccuracy !== reducedOptions.enableHighAccuracy) {
            this._targetGeolocationOptions = reducedOptions;
        }
        this.publishDeviceState();
    };
    DeviceServiceProvider.prototype.configureStage = function (longitude, latitude, altitude, geoHorizontalAccuracy, geoVerticalAccuracy) {
        var stage = this.deviceService.stage;
        if (defined(longitude) && defined(latitude)) {
            // TODO: fallback on https://cesiumjs.org/Cesium/Build/Documentation/sampleTerrain.html for height
            var height = defined(altitude) ? altitude : 0;
            var fixedPosition = Cartesian3.fromDegrees(longitude, latitude, height, undefined, this._scratchCartesianLocalOrigin);
            var enuOrientation = Transforms.headingPitchRollQuaternion(fixedPosition, 0, 0, 0, undefined, this._scratchQuaternionLocalOrigin);
            stage.position = stage.position || new ConstantPositionProperty();
            stage.orientation = stage.orientation || new ConstantProperty();
            stage.position.setValue(fixedPosition, ReferenceFrame.FIXED);
            stage.orientation.setValue(enuOrientation);
            stage['meta'] = {
                geoHorizontalAccuracy: geoHorizontalAccuracy,
                geoVerticalAccuracy: geoVerticalAccuracy
            };
        }
        else {
            stage.position = undefined;
            stage.orientation = undefined;
            stage['meta'] = undefined;
        }
    };
    /**
     * Overridable. Should call setGeolocation when new geolocation is available
     */
    DeviceServiceProvider.prototype.onStartGeolocationUpdates = function (options) {
        var _this = this;
        if (typeof navigator == 'undefined' || !navigator.geolocation)
            throw new Error('Unable to start geolocation updates');
        if (!defined(this._geolocationWatchId)) {
            this._geolocationWatchId = navigator.geolocation.watchPosition(function (pos) {
                _this.configureStage(pos.coords.longitude, pos.coords.latitude, pos.coords.altitude || 0, (pos.coords.accuracy > 0) ? pos.coords.accuracy : undefined, pos.coords.altitudeAccuracy || undefined);
            }, function (e) {
                console.warn('Unable to start geolocation updates: ' + e.message);
            }, options);
        }
    };
    /**
     * Overridable.
     */
    DeviceServiceProvider.prototype.onStopGeolocationUpdates = function () {
        if (typeof navigator !== 'undefined' && defined(this._geolocationWatchId)) {
            navigator.geolocation.clearWatch(this._geolocationWatchId);
            this._geolocationWatchId = undefined;
        }
    };
    return DeviceServiceProvider;
}());
DeviceServiceProvider = __decorate([
    autoinject(),
    __metadata("design:paramtypes", [SessionService,
        DeviceService,
        ContextService,
        ViewService,
        ContextServiceProvider])
], DeviceServiceProvider);
export { DeviceServiceProvider };
