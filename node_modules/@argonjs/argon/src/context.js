var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { autoinject } from 'aurelia-dependency-injection';
import { ReferenceEntity, Entity, EntityCollection, Cartographic, ConstantPositionProperty, ConstantProperty, Cartesian3, Quaternion, Matrix4, CesiumMath, JulianDate, ReferenceFrame, PerspectiveFrustum, defined } from './cesium/cesium-imports';
import { DEFAULT_NEAR_PLANE, DEFAULT_FAR_PLANE, SubviewType, Role } from './common';
import { SessionService } from './session';
import { Event, getReachableAncestorReferenceFrames, getSerializedEntityState, getEntityPositionInReferenceFrame, getEntityOrientationInReferenceFrame, deprecated, decomposePerspectiveProjectionMatrix } from './utils';
/**
 * Represents the pose of an entity relative to a particular reference frame.
 *
 * The `update` method must be called in order to update the position / orientation / poseStatus.
 */
var EntityPose = (function () {
    function EntityPose(context, entityOrId, referenceFrameId) {
        this.context = context;
        /**
         * The status of this pose, as a bitmask.
         *
         * If the current pose is known, then the KNOWN bit is 1.
         * If the current pose is not known, then the KNOWN bit is 0.
         *
         * If the previous pose was known and the current pose is unknown,
         * then the LOST bit is 1.
         * If the previous pose was unknown and the current pose status is known,
         * then the FOUND bit is 1.
         * In all other cases, both the LOST bit and the FOUND bit are 0.
         */
        this.status = 0;
        this.position = new Cartesian3;
        this.orientation = new Quaternion;
        this.time = new JulianDate(0, 0);
        this._previousStatus = 0;
        if (typeof entityOrId === 'string') {
            var entity = this.context.entities.getById(entityOrId);
            if (!entity)
                entity = new ReferenceEntity(context.entities, entityOrId);
            this._entity = entity;
        }
        else {
            this._entity = entityOrId;
        }
        if (typeof referenceFrameId === 'string') {
            var referenceFrame = this.context.entities.getById(referenceFrameId);
            if (!defined(referenceFrame))
                referenceFrame = new ReferenceEntity(context.entities, referenceFrameId);
            this._referenceFrame = referenceFrame;
        }
        else {
            this._referenceFrame = referenceFrameId;
        }
    }
    Object.defineProperty(EntityPose.prototype, "entity", {
        get: function () { return this._entity; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EntityPose.prototype, "referenceFrame", {
        get: function () {
            if (!defined(this._referenceFrame))
                return this.context.defaultReferenceFrame;
            return this._referenceFrame;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EntityPose.prototype, "poseStatus", {
        /**
         * alias for status
         */
        get: function () { return this.status; },
        enumerable: true,
        configurable: true
    });
    ;
    EntityPose.prototype.update = function (time) {
        if (time === void 0) { time = this.context.time; }
        JulianDate.clone(time, this.time);
        if (!JulianDate.equals(this._previousTime, time)) {
            this._previousStatus = this.status;
            this._previousTime = JulianDate.clone(time, this._previousTime);
        }
        var entity = this.entity;
        var referenceFrame = this.referenceFrame;
        var position = getEntityPositionInReferenceFrame(entity, time, referenceFrame, this.position);
        var orientation = getEntityOrientationInReferenceFrame(entity, time, referenceFrame, this.orientation);
        var hasPose = position && orientation;
        var currentStatus = 0;
        var previousStatus = this._previousStatus;
        if (hasPose) {
            currentStatus |= PoseStatus.KNOWN;
        }
        if (hasPose && !(previousStatus & PoseStatus.KNOWN)) {
            currentStatus |= PoseStatus.FOUND;
        }
        else if (!hasPose && previousStatus & PoseStatus.KNOWN) {
            currentStatus |= PoseStatus.LOST;
        }
        this.status = currentStatus;
    };
    return EntityPose;
}());
export { EntityPose };
/**
* A bitmask that provides metadata about the pose of an EntityPose.
*   KNOWN - the pose of the entity state is defined.
*   KNOWN & FOUND - the pose was undefined when the entity state was last queried, and is now defined.
*   LOST - the pose was defined when the entity state was last queried, and is now undefined
*/
export var PoseStatus;
(function (PoseStatus) {
    PoseStatus[PoseStatus["KNOWN"] = 1] = "KNOWN";
    PoseStatus[PoseStatus["FOUND"] = 2] = "FOUND";
    PoseStatus[PoseStatus["LOST"] = 4] = "LOST";
})(PoseStatus || (PoseStatus = {}));
/**
 * Provides a means of querying the current state of reality.
 *
 * This class adds the following message handlers to any sessions
 * managed by the session service:
 *
 *  * `ar.context.subscribe` - Subscribes the session to updates from an
 *    entity with the provided id.
 *    * Parameters:
 *      * id: string - The id of an entity the session wishes to recieve
 *        updates on.
 *
 * This service sends the following messages to managed sessions
 *
 *  * `ar.context.update` - Indicates to this context that the session wants
 *    to be focused on.
 */
var ContextService = (function () {
    function ContextService(sessionService) {
        var _this = this;
        this.sessionService = sessionService;
        /**
         * An event that is raised when the next frame state is available.
         */
        this.frameStateEvent = new Event();
        /**
         * An event that is raised after managed entities have been updated for
         * the current frame.
         */
        this.updateEvent = new Event();
        /**
         * An event that is raised when it is an approriate time to render graphics.
         * This event fires after the update event.
         */
        this.renderEvent = new Event();
        /**
         * An event that is raised after the render event
         */
        this.postRenderEvent = new Event();
        /**
         * An event that fires when the local origin changes.
         */
        this.localOriginChangeEvent = new Event();
        this._localOriginChanged = false;
        /**
         * A monotonically increasing value (in milliseconds) for the current frame state.
         * This value is useful only for doing accurate *timing*, not for determining
         * the absolute time. Use [[ContextService.time]] for absolute time.
         * This value is -1 until the first [[ContextService.updateEvent]].
         */
        this.timestamp = -1;
        /**
         * The time in milliseconds since the previous timestamp,
         * capped to [[ContextService.maxDeltaTime]]
         */
        this.deltaTime = 0;
        /**
         * This value caps the deltaTime for each frame. By default,
         * the value is 1/3s (333.3ms)
         */
        this.maxDeltaTime = 1 / 3 * 1000;
        /**
         * The current (absolute) time according to the current reality.
         * This value is arbitrary until the first [[ContextService.updateEvent]].
         */
        this.time = new JulianDate(0, 0);
        /**
         * The collection of all entities this application is aware of.
         */
        this.entities = new EntityCollection();
        /**
        * An entity representing the local origin, which is oriented
        * East-North-Up if geolocation is known, otherwise an arbitrary
        * frame with +Z up. The local origin changes infrequently and stays
        * near the user, making it useful as the root of a rendering scenegraph.
        *
        * Any time the local origin changes, the localOriginChange event is raised.
        */
        this.localOrigin = this.entities.add(new Entity({
            id: 'ar.localOrigin',
            name: 'Local Origin (ENU)',
            position: new ConstantPositionProperty(undefined, ReferenceFrame.FIXED),
            orientation: new ConstantProperty(undefined)
        }));
        /**
        * Alias for `localOrigin`. An entity representing the local origin,
        * which is oriented East-North-Up if geolocation is known,
        * otherwise an arbitrary frame with +Z up.
        */
        this.localOriginEastNorthUp = this.localOrigin;
        /**
         * An entity representing the same origin as `localOriginEastNorthUp`, but rotated
         * 90deg around X-axis to create an East-Up-South coordinate system.
         * Useful for maintaining a scene-graph where +Y is up.
         */
        this.localOriginEastUpSouth = this.entities.add(new Entity({
            id: 'ar.localOriginEUS',
            name: 'Local Origin (EUS)',
            position: new ConstantPositionProperty(Cartesian3.ZERO, this.localOriginEastNorthUp),
            orientation: new ConstantProperty(Quaternion.fromAxisAngle(Cartesian3.UNIT_X, Math.PI / 2))
        }));
        /**
         * The default origin to use when calling `getEntityPose`.
         * By default, this is the `localOriginEastNorthUp` reference frame.
         */
        this.defaultReferenceFrame = this.localOriginEastNorthUp;
        /**
         * An entity representing the physical floor beneath the user,
         * where +X is east, +Y is north, and +Z is up (if geolocation is known).
         */
        this.stage = this.entities.add(new Entity({
            id: 'ar.stage',
            name: 'Stage (ENU)',
            position: new ConstantPositionProperty(undefined, ReferenceFrame.FIXED),
            orientation: new ConstantProperty(undefined)
        }));
        /**
         * Alias for `stage`. An entity representing the stage,
         * which is oriented East-North-Up if geolocation is known,
         * otherwise an arbitrary frame with +Z up.
         */
        this.stageEastNorthUp = this.stage;
        /**
         * An entity representing the same origin as `stageEastNorthUp`,
         * but rotated 90deg around X-axis to create an East-Up-South coordinate system,
         * such that +Y is up.
         */
        this.stageEastUpSouth = this.entities.add(new Entity({
            id: 'ar.stageEUS',
            name: 'Stage (EUS)',
            position: new ConstantPositionProperty(Cartesian3.ZERO, this.localOriginEastNorthUp),
            orientation: new ConstantProperty(Quaternion.fromAxisAngle(Cartesian3.UNIT_X, Math.PI / 2))
        }));
        /**
         * An entity representing the user,
         * where +X is right, +Y is up, and -Z is the direction the user is facing
         */
        this.user = this.entities.add(new Entity({
            id: 'ar.user',
            name: 'User',
            position: new ConstantPositionProperty(undefined, this.stage),
            orientation: new ConstantProperty(undefined)
        }));
        /**
         * An entity representing the rendering view,
         * where +X is right, +Y is up, and -z is the direction of the view
         */
        this.view = this.entities.add(new Entity({
            id: 'ar.view',
            name: 'View',
            position: new ConstantPositionProperty(Cartesian3.ZERO, this.user),
            orientation: new ConstantProperty(Quaternion.IDENTITY)
        }));
        /**
         * An entity representing the floor beneath the user
         */
        this.floor = this.entities.add(new Entity({
            id: 'ar.floor',
            name: 'Floor',
            position: new ConstantPositionProperty(Cartesian3.ZERO, this.stage),
            orientation: new ConstantProperty(Quaternion.IDENTITY)
        }));
        this._entityPoseMap = new Map();
        this._updatingEntities = new Set();
        this._knownEntities = new Set();
        this._scratchCartesian = new Cartesian3;
        this._scratchQuaternion = new Quaternion;
        this._scratchFrustum = new PerspectiveFrustum();
        this._frameIndex = -1;
        this._getReachableAncestorReferenceFrames = getReachableAncestorReferenceFrames;
        this._scratchArray = [];
        this._localOriginPose = this.createEntityPose(this.localOrigin, this.stage);
        this.sessionService.manager.on['ar.context.update'] = function (state) {
            var scratchFrustum = _this._scratchFrustum;
            // backwards-compat
            if (typeof state.reality !== 'string') {
                state.reality = state.reality && state.reality['uri'];
            }
            if (!state.viewport && state['view'] && state['view'].viewport) {
                state.viewport = state['view'].viewport;
            }
            if (!state.subviews && state['view'] && state['view'].subviews) {
                state.subviews = state['view'].subviews;
                scratchFrustum.near = DEFAULT_NEAR_PLANE;
                scratchFrustum.far = DEFAULT_FAR_PLANE;
                for (var _i = 0, _a = state.subviews; _i < _a.length; _i++) {
                    var s = _a[_i];
                    var frustum = s['frustum'];
                    scratchFrustum.xOffset = frustum.xOffset || 0;
                    scratchFrustum.yOffset = frustum.yOffset || 0;
                    scratchFrustum.fov = frustum.fov || CesiumMath.PI_OVER_THREE;
                    scratchFrustum.aspectRatio = frustum.aspectRatio || 1;
                    s.projectionMatrix = Matrix4.clone(scratchFrustum.projectionMatrix, s.projectionMatrix);
                }
            }
            if (!state.entities[_this.user.id] && state['view'] && state['view'].pose) {
                state.entities[_this.user.id] = state['view'].pose;
            }
            // end backwards-compat
            _this._update(state);
        };
        this.localOrigin.definitionChanged.addEventListener(function (localOrigin, property) {
            if (property === 'position' || property === 'orientation') {
                if (localOrigin.position) {
                    localOrigin.position.definitionChanged.addEventListener(function () {
                        _this._localOriginChanged = true;
                    });
                }
                if (localOrigin.orientation) {
                    localOrigin.orientation.definitionChanged.addEventListener(function () {
                        _this._localOriginChanged = true;
                    });
                }
                _this._localOriginChanged = true;
            }
        });
        this._scratchFrustum.near = DEFAULT_NEAR_PLANE;
        this._scratchFrustum.far = DEFAULT_FAR_PLANE;
        this._scratchFrustum.fov = CesiumMath.PI_OVER_THREE;
        this._scratchFrustum.aspectRatio = 1;
        this._serializedFrameState = {
            reality: undefined,
            time: JulianDate.now(),
            entities: {},
            viewport: { x: 0, y: 0, width: 0, height: 0 },
            subviews: [{
                    type: SubviewType.SINGULAR,
                    pose: null,
                    viewport: { x: 0, y: 0, width: 1, height: 1 },
                    projectionMatrix: this._scratchFrustum.projectionMatrix
                }],
        };
    }
    Object.defineProperty(ContextService.prototype, "geoposeHeadingAccuracy", {
        get: function () {
            return this.stage['meta'].geoposeHeadingAccuracy;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ContextService.prototype, "geoposeHorizontalAccuracy", {
        get: function () {
            return this.stage['meta'].geoposeHorizontalAccuracy;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ContextService.prototype, "geoposeVerticalAccuracy", {
        get: function () {
            return this.stage['meta'].geoposeVerticalAccuracy;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ContextService.prototype, "serializedFrameState", {
        /**
         * The serialized frame state for this frame
         */
        get: function () {
            return this._serializedFrameState;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ContextService.prototype, "systemTime", {
        /**
         * Deprecated. Use timestamp property.
         * @private
         */
        get: function () {
            return this.timestamp;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Deprecated. To be removed.
     * @private
     */
    ContextService.prototype.getTime = function () {
        return this.time;
    };
    /**
     * Deprecated. To be removed. Use the defaultReferenceFrame property.
     * @private
     */
    ContextService.prototype.setDefaultReferenceFrame = function (origin) {
        this.defaultReferenceFrame = origin;
    };
    /**
     * Deprecated. To be removed.  Use the defaultReferenceFrame property.
     * @private
     */
    ContextService.prototype.getDefaultReferenceFrame = function () {
        return this.defaultReferenceFrame;
    };
    /**
     * Subscribe to pose updates for an entity specified by the given id
     *
     * @deprecated Use [[ContextService#subscribe]]
     * @param id - the id of the desired entity
     * @returns A new or existing entity instance matching the given id
     */
    ContextService.prototype.subscribeToEntityById = function (id) {
        this.sessionService.manager.send('ar.context.subscribe', { id: id });
        return this.entities.getOrCreateEntity(id);
    };
    /**
     * Subscribe to pose updates for the given entity id
     *
     * @returns A Promise that resolves to a new or existing entity
     * instance matching the given id, if the subscription is successful
     */
    ContextService.prototype.subscribe = function (id, session) {
        var _this = this;
        if (session === void 0) { session = this.sessionService.manager; }
        id = id.id || id;
        return session.request('ar.context.subscribe', { id: id }).then(function () {
            return _this.entities.getOrCreateEntity(id);
        });
    };
    /**
     * Unsubscribe to pose updates for the given entity id
     */
    ContextService.prototype.unsubscribe = function (id, session) {
        if (session === void 0) { session = this.sessionService.manager; }
        id = id.id || id;
        session.send('ar.context.unsubscribe', { id: id });
    };
    /**
     * Get the cartographic position of an Entity
     */
    ContextService.prototype.getEntityCartographic = function (entity, cartographic) {
        if (!entity)
            return undefined;
        var fixedPosition = getEntityPositionInReferenceFrame(entity, this.time, ReferenceFrame.FIXED, this._scratchCartesian);
        if (fixedPosition) {
            cartographic = cartographic || new Cartographic();
            return Cartographic.fromCartesian(fixedPosition, undefined, cartographic);
        }
        return undefined;
    };
    /**
     * Create a new EntityPose instance to represent the pose of an entity
     * relative to a given reference frame. If no reference frame is specified,
     * then the pose is based on the context's defaultReferenceFrame.
     *
     * @param entity - the entity to track
     * @param referenceFrameOrId - the reference frame to use
     */
    ContextService.prototype.createEntityPose = function (entityOrId, referenceFrameOrId) {
        return new EntityPose(this, entityOrId, referenceFrameOrId);
    };
    /**
     * Gets the current pose of an entity, relative to a given reference frame.
     *
     * @deprecated
     * @param entity - The entity whose state is to be queried.
     * @param referenceFrame - The intended reference frame. Defaults to `this.defaultReferenceFrame`.
     */
    ContextService.prototype.getEntityPose = function (entityOrId, referenceFrameOrId) {
        if (referenceFrameOrId === void 0) { referenceFrameOrId = this.defaultReferenceFrame; }
        var key = this._stringFromReferenceFrame(entityOrId) + '@' + this._stringFromReferenceFrame(referenceFrameOrId);
        var entityPose = this._entityPoseMap.get(key);
        if (!entityPose) {
            entityPose = this.createEntityPose(entityOrId, referenceFrameOrId);
            this._entityPoseMap.set(key, entityPose);
        }
        entityPose.update();
        return entityPose;
    };
    /**
     * Process the next frame state (which should come from the current reality viewer)
     */
    ContextService.prototype.submitFrameState = function (frameState) {
        frameState.index = ++this._frameIndex;
        this._update(frameState);
    };
    // All of the following work is only necessary when running in an old manager (version === 0)
    ContextService.prototype._updateBackwardsCompatability = function (frameState) {
        this._knownEntities.clear();
        // update the entities the manager knows about
        for (var id in frameState.entities) {
            this.updateEntityFromSerializedState(id, frameState.entities[id]);
            this._updatingEntities.add(id);
            this._knownEntities.add(id);
        }
        // if the mangager didn't send us an update for a particular entity,
        // assume the manager no longer knows about it
        for (var _i = 0, _a = this._updatingEntities; _i < _a.length; _i++) {
            var id = _a[_i];
            if (!this._knownEntities.has(id)) {
                var entity = this.entities.getById(id);
                if (entity) {
                    if (entity.position)
                        entity.position.setValue(undefined);
                    if (entity.orientation)
                        entity.orientation.setValue(undefined);
                }
                this._updatingEntities.delete(id);
            }
        }
    };
    // TODO: This function is called a lot. Potential for optimization. 
    ContextService.prototype._update = function (frameState) {
        var entities = frameState.entities;
        if (this.sessionService.manager.isConnected && this.sessionService.manager.version[0] === 0) {
            this._updateBackwardsCompatability(frameState);
        }
        else {
            for (var id in entities) {
                this.updateEntityFromSerializedState(id, entities[id]);
            }
        }
        // update our time values
        var timestamp = performance.now();
        this.deltaTime = Math.min(timestamp - this.timestamp, this.maxDeltaTime);
        this.timestamp = timestamp;
        JulianDate.clone(frameState.time, this.time);
        // if (entities[this.stage.id]) {}
        // this._updateStage(frameState);
        // raise a frame state event (primarily for other services to hook into)
        this._serializedFrameState = frameState;
        this.frameStateEvent.raiseEvent(frameState);
        // update our local origin.
        this._updateLocalOrigin(frameState);
        // raise events for the user to update and render the scene
        if (this._localOriginChanged) {
            this._localOriginChanged = false;
            this.localOriginChangeEvent.raiseEvent(undefined);
        }
        this.updateEvent.raiseEvent(this);
        this.renderEvent.raiseEvent(this);
        this.postRenderEvent.raiseEvent(this);
    };
    ContextService.prototype._updateLocalOrigin = function (frameState) {
        var localOrigin = this.localOrigin;
        var stage = this.stage;
        var time = frameState.time;
        var localOriginPose = this._localOriginPose;
        localOriginPose.update(time);
        if ((localOriginPose.status & PoseStatus.KNOWN) === 0 ||
            Cartesian3.magnitudeSquared(localOriginPose.position) > 10000) {
            var stageFrame = this._getReachableAncestorReferenceFrames(stage, time, this._scratchArray)[0];
            if (defined(stageFrame)) {
                var stagePositionValue = stage.position.getValueInReferenceFrame(time, stageFrame, this._scratchCartesian);
                var stageOrientationValue = stage.orientation.getValue(time, this._scratchQuaternion);
                if (stagePositionValue && stageOrientationValue) {
                    console.log('Updating local origin to ' + JSON.stringify(stagePositionValue) + " at " + this._stringFromReferenceFrame(stageFrame));
                    localOrigin.position.setValue(stagePositionValue, stageFrame);
                    localOrigin.orientation.setValue(stageOrientationValue);
                    return;
                }
            }
        }
        else {
            return;
        }
        localOrigin.position.setValue(Cartesian3.ZERO, stage);
        localOrigin.orientation.setValue(Quaternion.IDENTITY);
    };
    ContextService.prototype.updateEntityFromSerializedState = function (id, entityState) {
        var entity = this.entities.getOrCreateEntity(id);
        if (!entityState) {
            if (entity.position) {
                entity.position.setValue(undefined);
            }
            if (entity.orientation) {
                entity.orientation.setValue(undefined);
            }
            entity['meta'] = undefined;
            return entity;
        }
        var positionValue = entityState.p;
        var orientationValue = Quaternion.clone(entityState.o, this._scratchQuaternion); // workaround for https://github.com/AnalyticalGraphicsInc/cesium/issues/5031
        var referenceFrame = typeof entityState.r === 'number' ?
            entityState.r : this.entities.getOrCreateEntity(entityState.r);
        var entityPosition = entity.position;
        var entityOrientation = entity.orientation;
        if (entityPosition instanceof ConstantPositionProperty &&
            entityPosition.referenceFrame === referenceFrame) {
            entityPosition.setValue(positionValue, referenceFrame);
        }
        else {
            entity.position = new ConstantPositionProperty(positionValue, referenceFrame);
        }
        if (entityOrientation instanceof ConstantProperty) {
            entityOrientation.setValue(orientationValue);
        }
        else {
            entity.orientation = new ConstantProperty(orientationValue);
        }
        entity['meta'] = entityState.meta;
        return entity;
    };
    ContextService.prototype.getSubviewEntity = function (index) {
        var subviewEntity = this.entities.getOrCreateEntity('ar.view_' + index);
        if (!subviewEntity.position) {
            subviewEntity.position = new ConstantPositionProperty();
        }
        if (!subviewEntity.orientation) {
            subviewEntity.orientation = new ConstantProperty();
        }
        return subviewEntity;
    };
    ContextService.prototype.subscribeGeolocation = function (options) {
        var _this = this;
        return this.sessionService.manager.whenConnected().then(function () {
            if (_this.sessionService.manager.version[0] > 0)
                _this.sessionService.manager.send('ar.context.setGeolocationOptions', { options: options });
            return _this.subscribe(_this.stage.id).then(function () { });
        });
    };
    ContextService.prototype.unsubscribeGeolocation = function () {
        this.unsubscribe(this.stage.id);
    };
    Object.defineProperty(ContextService.prototype, "geoHeadingAccuracy", {
        get: function () {
            return this.user['meta'] && this.user['meta'].geoHeadingAccuracy;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ContextService.prototype, "geoHorizontalAccuracy", {
        get: function () {
            return this.user['meta'] && this.user['meta'].geoHorizontalAccuracy ||
                this.stage['meta'] && this.stage['meta'].geoHorizontalAccuracy;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ContextService.prototype, "geoVerticalAccuracy", {
        get: function () {
            return this.user['meta'] && this.user['meta'].geoVerticalAccuracy ||
                this.stage['meta'] && this.stage['meta'].geoVerticalAccuracy;
        },
        enumerable: true,
        configurable: true
    });
    ContextService.prototype._stringFromReferenceFrame = function (referenceFrame) {
        var rf = referenceFrame;
        return defined(rf.id) ? rf.id : '' + rf;
    };
    return ContextService;
}());
__decorate([
    deprecated('timestamp'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], ContextService.prototype, "systemTime", null);
__decorate([
    deprecated('time'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", JulianDate)
], ContextService.prototype, "getTime", null);
__decorate([
    deprecated('defaultReferenceFrame'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Entity]),
    __metadata("design:returntype", void 0)
], ContextService.prototype, "setDefaultReferenceFrame", null);
__decorate([
    deprecated('defaultReferenceFrame'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Entity)
], ContextService.prototype, "getDefaultReferenceFrame", null);
__decorate([
    deprecated('subscribe'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Entity)
], ContextService.prototype, "subscribeToEntityById", null);
ContextService = __decorate([
    autoinject(),
    __metadata("design:paramtypes", [SessionService])
], ContextService);
export { ContextService };
var ContextServiceProvider = (function () {
    function ContextServiceProvider(sessionService, contextService) {
        var _this = this;
        this.sessionService = sessionService;
        this.contextService = contextService;
        this.entitySubscriptionsBySubscriber = new WeakMap();
        this.subscribersByEntityId = new Map();
        this.subscribersChangeEvent = new Event();
        this.publishingReferenceFrameMap = new Map();
        this._cacheTime = new JulianDate(0, 0);
        this._entityPoseCache = {};
        this._getSerializedEntityState = getSerializedEntityState;
        this._sessionEntities = {};
        this._temp = {};
        this.desiredGeolocationOptions = {};
        this.sessionGeolocationOptions = new Map();
        this.publishingReferenceFrameMap.set(this.contextService.stage.id, ReferenceFrame.FIXED);
        sessionService.connectEvent.addEventListener(function (session) {
            var subscriptions = {};
            _this.entitySubscriptionsBySubscriber.set(session, subscriptions);
            session.on['ar.context.subscribe'] = function (_a) {
                var id = _a.id;
                if (subscriptions[id])
                    return;
                var subscribers = _this.subscribersByEntityId.get(id) || new Set();
                _this.subscribersByEntityId.set(id, subscribers);
                subscribers.add(session);
                subscriptions[id] = true;
                _this.subscribersChangeEvent.raiseEvent({ id: id, subscribers: subscribers });
                session.closeEvent.addEventListener(function () {
                    subscribers.delete(session);
                    _this.subscribersChangeEvent.raiseEvent({ id: id, subscribers: subscribers });
                });
            };
            session.on['ar.context.unsubscribe'] = function (_a) {
                var id = _a.id;
                if (!subscriptions[id])
                    return;
                var subscribers = _this.subscribersByEntityId.get(id);
                subscribers && subscribers.delete(session);
                delete subscriptions[id];
                _this.subscribersChangeEvent.raiseEvent({ id: id, subscribers: subscribers });
            };
            session.on['ar.context.setGeolocationOptions'] = function (_a) {
                var options = _a.options;
                _this._handleSetGeolocationOptions(session, options);
            };
            session.closeEvent.addEventListener(function () {
                _this.entitySubscriptionsBySubscriber.delete(session);
                for (var id in subscriptions) {
                    var subscribers = _this.subscribersByEntityId.get(id);
                    subscribers && subscribers.delete(session);
                    _this.subscribersChangeEvent.raiseEvent({ id: id, subscribers: subscribers });
                }
            });
        });
        this.contextService.updateEvent.addEventListener(function () {
            _this._publishUpdates();
        });
    }
    ContextServiceProvider.prototype.fillEntityStateMapForSession = function (session, time, entities) {
        var subscriptions = this.entitySubscriptionsBySubscriber.get(session);
        if (!subscriptions)
            return;
        for (var id in subscriptions) {
            var entity = this.contextService.entities.getById(id);
            entities[id] = entity ? this._getCachedSerializedEntityState(entity, time) : null;
        }
    };
    ContextServiceProvider.prototype._publishUpdates = function () {
        var state = this.contextService.serializedFrameState;
        this._cacheTime = JulianDate.clone(state.time, this._cacheTime);
        for (var _i = 0, _a = this.sessionService.managedSessions; _i < _a.length; _i++) {
            var session = _a[_i];
            if (Role.isRealityAugmenter(session.info.role))
                this._sendUpdateForSession(state, session);
        }
    };
    ContextServiceProvider.prototype._sendUpdateForSession = function (state, session) {
        var sessionEntities = this._sessionEntities;
        // clear session entities
        for (var id in sessionEntities) {
            delete sessionEntities[id];
        }
        // reference all entities from the primary frame state
        if (state.entities) {
            for (var id in state.entities) {
                sessionEntities[id] = state.entities[id];
            }
        }
        // get subscribed entities for the session
        var subscriptions = this.entitySubscriptionsBySubscriber.get(session);
        // exclude the stage state unless it is explicitly subscribed 
        var contextService = this.contextService;
        var contextStageId = contextService.stage.id;
        if (!subscriptions[contextStageId])
            delete sessionEntities[contextStageId];
        // add the entity states for all subscribed entities
        for (var id_1 in subscriptions) {
            var entity = contextService.entities.getById(id_1);
            sessionEntities[id_1] = this._getCachedSerializedEntityState(entity, state.time);
        }
        // recycle the frame state object, but with the session entities
        var parentEntities = state.entities;
        state.entities = sessionEntities;
        state.time = state.time;
        state.sendTime = JulianDate.now(state.sendTime);
        if (session.version[0] === 0) {
            for (var _i = 0, _a = state.subviews; _i < _a.length; _i++) {
                var s = _a[_i];
                s['frustum'] = s['frustum'] || decomposePerspectiveProjectionMatrix(s.projectionMatrix, {});
            }
            var view = this._temp;
            view.viewport = state.viewport;
            view.subviews = state.subviews;
            view.pose = state.entities['ar.user'];
            delete state.subviews;
            delete state.viewport;
            delete state.entities['ar.user'];
            state['view'] = view;
            session.send('ar.context.update', state);
            delete state['view'];
            state.viewport = view.viewport;
            state.subviews = view.subviews;
        }
        else {
            session.send('ar.context.update', state);
        }
        // restore the parent entities
        state.entities = parentEntities;
    };
    ContextServiceProvider.prototype._getCachedSerializedEntityState = function (entity, time) {
        if (!entity)
            return null;
        var id = entity.id;
        if (!defined(this._entityPoseCache[id]) || this._cacheTime.equalsEpsilon(time, 0.000001)) {
            var referenceFrameId = this.publishingReferenceFrameMap.get(id);
            var referenceFrame = defined(referenceFrameId) && typeof referenceFrameId === 'string' ?
                this.contextService.entities.getById(referenceFrameId) :
                defined(referenceFrameId) ? referenceFrameId : this.contextService.stage;
            this._entityPoseCache[id] = this._getSerializedEntityState(entity, time, referenceFrame);
        }
        return this._entityPoseCache[id];
    };
    ContextServiceProvider.prototype._handleSetGeolocationOptions = function (session, options) {
        var _this = this;
        this.sessionGeolocationOptions.set(session, options);
        session.closeEvent.addEventListener(function () {
            _this.sessionGeolocationOptions.delete(session);
            _this._updateDesiredGeolocationOptions();
        });
        this._updateDesiredGeolocationOptions();
    };
    ContextServiceProvider.prototype._updateDesiredGeolocationOptions = function () {
        var reducedOptions = {};
        this.sessionGeolocationOptions.forEach(function (options, session) {
            reducedOptions.enableHighAccuracy =
                reducedOptions.enableHighAccuracy || (options && options.enableHighAccuracy) || false;
        });
        if (this.desiredGeolocationOptions.enableHighAccuracy !== reducedOptions.enableHighAccuracy) {
            this.desiredGeolocationOptions = reducedOptions;
        }
    };
    Object.defineProperty(ContextServiceProvider.prototype, "geolocationDesired", {
        get: function () {
            var contextGeoposeSubscribers = this.subscribersByEntityId.get(this.contextService.stage.id);
            if (contextGeoposeSubscribers && contextGeoposeSubscribers.size > 0)
                return true;
            return false;
        },
        enumerable: true,
        configurable: true
    });
    return ContextServiceProvider;
}());
ContextServiceProvider = __decorate([
    autoinject(),
    __metadata("design:paramtypes", [SessionService,
        ContextService])
], ContextServiceProvider);
export { ContextServiceProvider };
