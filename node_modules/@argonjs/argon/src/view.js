var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { autoinject, inject, Optional } from 'aurelia-dependency-injection';
import { Viewport } from './common';
import { SessionService } from './session';
import { ContextService } from './context';
import { PerspectiveFrustum, Cartesian3, Quaternion } from './cesium/cesium-imports';
import { Event, isIOS, createEventForwarder, synthesizeEvent, decomposePerspectiveProjectionMatrix, deprecated } from './utils';
import { FocusService, FocusServiceProvider } from './focus';
import { VisibilityServiceProvider } from './visibility';
/**
 * The rendering paramters for a particular subview
 */
var Subview = (function () {
    function Subview() {
    }
    return Subview;
}());
export { Subview };
var ViewElement = (function () {
    function ViewElement() {
    }
    return ViewElement;
}());
export { ViewElement };
;
/**
 * Manages the view state
 */
var ViewService = (function () {
    function ViewService(sessionService, contextService, focusService, elementOrSelector) {
        var _this = this;
        this.sessionService = sessionService;
        this.contextService = contextService;
        this.focusService = focusService;
        /**
         * UI events that occur within this view. To handle an event (and prevent it from
         * being forwarded to another layer) call event.stopImmediatePropagation().
         */
        this.uiEvent = new Event();
        /**
         * An event that is raised when the viewport has changed
         */
        this.viewportChangeEvent = new Event();
        /**
         * An event that is raised when the viewport mode has changed
         */
        this.viewportModeChangeEvent = new Event();
        this._mode = 0 /* EMBEDDED */;
        this._viewport = { x: 0, y: 0, width: 0, height: 0 };
        /**
         * Automatically layout the element to match the immersive viewport during PresentationMode.IMMERSIVE
         */
        this.autoLayoutImmersiveMode = true;
        /**
         * Automatically publish the viewport of the element during PresentationMode.EMBEDDED
         */
        this.autoPublishEmbeddedMode = true;
        this._subviews = [];
        this._subviewPose = [];
        this._subviewFrustum = [];
        this._IDENTITY_SUBVIEW_POSE = { p: Cartesian3.ZERO, o: Quaternion.IDENTITY, r: this.contextService.view.id };
        this._desiredViewportMode = this.viewportMode;
        this._embeddedViewport = new Viewport;
        if (typeof document !== 'undefined' && document.createElement) {
            var element = elementOrSelector;
            if (!element || typeof element === 'string') {
                var selector = element;
                element = selector ? document.querySelector(selector) : undefined;
                if (!element && !selector) {
                    element = document.querySelector('#argon');
                    if (!element) {
                        element = document.createElement('div');
                        element.id = 'argon';
                        document.body.appendChild(element);
                    }
                }
                else if (!element) {
                    throw new Error('Unable to find element with selector: ' + selector);
                }
            }
            this.element = element;
            element.classList.add('argon-view');
            // prevent pinch-zoom of the page in ios 10.
            if (isIOS) {
                var touchMoveListener_1 = function (event) {
                    if (event.touches.length > 1)
                        event.preventDefault();
                };
                this.element.addEventListener('touchmove', touchMoveListener_1, true);
                this.sessionService.manager.closeEvent.addEventListener(function () {
                    _this.element.removeEventListener('touchmove', touchMoveListener_1);
                });
            }
            this.focusService.focusEvent.addEventListener(function () {
                document.documentElement.classList.remove('argon-no-focus');
                document.documentElement.classList.remove('argon-blur');
                document.documentElement.classList.add('argon-focus');
            });
            this.focusService.blurEvent.addEventListener(function () {
                document.documentElement.classList.remove('argon-focus');
                document.documentElement.classList.add('argon-blur');
                document.documentElement.classList.add('argon-no-focus');
            });
            this.viewportModeChangeEvent.addEventListener(function (mode) {
                switch (mode) {
                    case 0 /* EMBEDDED */:
                        document.documentElement.classList.remove('argon-immersive');
                        break;
                    case 1 /* IMMERSIVE */:
                        document.documentElement.classList.add('argon-immersive');
                        break;
                }
            });
            this.sessionService.manager.on['ar.view.uievent'] = synthesizeEvent;
            if (!this.sessionService.isRealityViewer) {
                createEventForwarder(this, function (event) {
                    if (_this.sessionService.manager.isConnected && _this.sessionService.manager.version[0] >= 1)
                        _this.sessionService.manager.send('ar.view.forwardUIEvent', event);
                });
                this._watchEmbeddedViewport();
            }
        }
        sessionService.manager.on['ar.view.viewportMode'] =
            function (_a) {
                var mode = _a.mode;
                _this._updateViewportMode(mode);
            };
        // if we are not the manager, we must start in immersive mode
        if (!sessionService.isRealityManager)
            this._updateViewportMode(1 /* IMMERSIVE */);
        // if we are loaded in an older manager which does not support embedded mode,
        // then switch to immersive mode
        sessionService.manager.connectEvent.addEventListener(function () {
            if (sessionService.manager.version[0] === 0 ||
                !sessionService.isRealityManager) {
                _this._updateViewportMode(1 /* IMMERSIVE */);
            }
        });
        // keep the subviews up-to-date
        this.contextService.frameStateEvent.addEventListener(function (state) {
            _this._processFrameState(state);
        });
        this._processFrameState(this.contextService.serializedFrameState);
    }
    Object.defineProperty(ViewService.prototype, "viewportMode", {
        /**
         * The current viewport mode
         */
        get: function () { return this._mode; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewService.prototype, "presentationMode", {
        get: function () { return this.viewportMode; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewService.prototype, "viewport", {
        /**
         * The current viewport
         */
        get: function () {
            return this._viewport;
        },
        enumerable: true,
        configurable: true
    });
    ViewService.prototype.getViewport = function () {
        return this.viewport;
    };
    Object.defineProperty(ViewService.prototype, "subviews", {
        get: function () {
            return this._subviews;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     */
    ViewService.prototype.getSubviews = function () {
        return this.subviews;
    };
    ViewService.prototype._processFrameState = function (state) {
        this._updateViewport(state.viewport);
        var serializedSubviewList = state.subviews;
        var subviews = this._subviews;
        subviews.length = serializedSubviewList.length;
        var index = 0;
        for (var _i = 0, serializedSubviewList_1 = serializedSubviewList; _i < serializedSubviewList_1.length; _i++) {
            var serializedSubview = serializedSubviewList_1[_i];
            var subviewPose = serializedSubview.pose || this._IDENTITY_SUBVIEW_POSE;
            var subviewEntity = this.contextService.getSubviewEntity(index);
            this.contextService.updateEntityFromSerializedState(subviewEntity.id, subviewPose);
            var subview = subviews[index] = subviews[index] || {};
            subview.index = index;
            subview.type = serializedSubview.type;
            subview.viewport = subview.viewport || {};
            subview.viewport.x = serializedSubview.viewport.x;
            subview.viewport.y = serializedSubview.viewport.y;
            subview.viewport.width = serializedSubview.viewport.width;
            subview.viewport.height = serializedSubview.viewport.height;
            subview.frustum = this._subviewFrustum[index] =
                this._subviewFrustum[index] || new PerspectiveFrustum();
            decomposePerspectiveProjectionMatrix(serializedSubview.projectionMatrix, subview.frustum);
            subview['projectionMatrix'] = subview.frustum.projectionMatrix;
            subview.pose = this._subviewPose[index] =
                this._subviewPose[index] || this.contextService.createEntityPose(subviewEntity);
            subview.pose.update();
            index++;
        }
    };
    ViewService.prototype.requestPresentationMode = function (mode) {
        return this.sessionService.manager.request('ar.view.desiredViewportMode', { mode: mode });
    };
    Object.defineProperty(ViewService.prototype, "desiredViewportMode", {
        get: function () {
            return this._desiredViewportMode;
        },
        set: function (mode) {
            var _this = this;
            this._desiredViewportMode = mode;
            this.sessionService.manager.whenConnected().then(function () {
                if (_this.sessionService.manager.version[0] > 0)
                    _this.sessionService.manager.send('ar.view.desiredViewportMode', { mode: mode });
            });
        },
        enumerable: true,
        configurable: true
    });
    ViewService.prototype._updateViewportMode = function (mode) {
        var currentMode = this.viewportMode;
        if (currentMode !== mode) {
            this._mode = mode;
            this.viewportModeChangeEvent.raiseEvent(mode);
        }
    };
    /**
     * Publish the viewport being used in [[PresentationMode.EMBEDDED]]
     * so that the manager knows what our embedded viewport is
     */
    ViewService.prototype.publishEmbeddedViewport = function (viewport) {
        if (this.sessionService.manager.isConnected &&
            this.sessionService.manager.version[0] >= 1)
            this.sessionService.manager.send('ar.view.embeddedViewport', { viewport: viewport });
    };
    // Updates the element, if necessary, and raise a view change event
    ViewService.prototype._updateViewport = function (viewport) {
        var _this = this;
        var viewportJSON = JSON.stringify(viewport);
        if (!this._currentViewportJSON || this._currentViewportJSON !== viewportJSON) {
            this._currentViewportJSON = viewportJSON;
            this._viewport = Viewport.clone(viewport, this._viewport);
            if (this.element &&
                !this.sessionService.isRealityManager &&
                this.autoLayoutImmersiveMode &&
                this.viewportMode === 1 /* IMMERSIVE */) {
                requestAnimationFrame(function () {
                    _this.element.style.position = 'fixed';
                    _this.element.style.left = viewport.x + 'px';
                    _this.element.style.bottom = viewport.y + 'px';
                    _this.element.style.width = viewport.width + 'px';
                    _this.element.style.height = viewport.height + 'px';
                });
            }
            this.viewportChangeEvent.raiseEvent(viewport);
        }
    };
    ViewService.prototype.sendUIEventToSession = function (uievent, session) {
        if (session && session.isConnected)
            session.send('ar.view.uievent', uievent);
    };
    ViewService.prototype._watchEmbeddedViewport = function () {
        var _this = this;
        var publish = function () {
            if (_this.element && _this.autoPublishEmbeddedMode) {
                var parentElement = _this.element.parentElement;
                var rect = parentElement && parentElement.getBoundingClientRect();
                if (rect) {
                    var x = rect.left;
                    var y = window.innerHeight - rect.bottom;
                    var width = rect.width;
                    var height = rect.height;
                    var embeddedViewport = _this._embeddedViewport;
                    if (embeddedViewport.x !== x ||
                        embeddedViewport.y !== y ||
                        embeddedViewport.width !== width ||
                        embeddedViewport.height !== height) {
                        embeddedViewport.x = x;
                        embeddedViewport.y = y;
                        embeddedViewport.width = width;
                        embeddedViewport.height = height;
                        _this.publishEmbeddedViewport(_this._embeddedViewport);
                    }
                }
            }
        };
        setInterval(function () {
            if (!_this.focusService.hasFocus)
                publish();
        }, 500);
        this.contextService.frameStateEvent.addEventListener(function () {
            if (_this.focusService.hasFocus)
                publish();
        });
    };
    return ViewService;
}());
__decorate([
    deprecated('viewportMode'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], ViewService.prototype, "presentationMode", null);
__decorate([
    deprecated('viewport'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], ViewService.prototype, "getViewport", null);
__decorate([
    deprecated('subviews'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], ViewService.prototype, "getSubviews", null);
__decorate([
    deprecated('desiredViewportMode'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number]),
    __metadata("design:returntype", Promise)
], ViewService.prototype, "requestPresentationMode", null);
ViewService = __decorate([
    inject(SessionService, ContextService, FocusService, Optional.of(ViewElement)),
    __metadata("design:paramtypes", [SessionService,
        ContextService,
        FocusService, Object])
], ViewService);
export { ViewService };
var ViewServiceProvider = (function () {
    function ViewServiceProvider(sessionService, viewportService, focusServiceProvider, visibilityServiceProvider) {
        var _this = this;
        this.sessionService = sessionService;
        this.viewportService = viewportService;
        this.focusServiceProvider = focusServiceProvider;
        this.sessionViewportMode = new WeakMap();
        /**
         * The embedded viewports for each managed session.
         */
        this.sessionEmbeddedViewport = new WeakMap();
        /**
         * A UI event being forwarded from a managed session
         */
        this.forwardedUIEvent = new Event();
        sessionService.ensureIsRealityManager();
        sessionService.connectEvent.addEventListener(function (session) {
            _this.sessionViewportMode.set(session, session === _this.sessionService.manager ?
                _this.viewportService.desiredViewportMode :
                1 /* IMMERSIVE */);
            // forward ui events to the visible reality viewer
            session.on['ar.view.forwardUIEvent'] = function (uievent) {
                _this.forwardedUIEvent.raiseEvent(uievent);
            };
            session.on['ar.view.desiredViewportMode'] = function (_a) {
                var mode = _a.mode;
                _this.sessionViewportMode.set(session, mode);
                _this._publishViewportModes();
            };
            session.on['ar.view.embeddedViewport'] = function (viewport) {
                _this.sessionEmbeddedViewport.set(session, viewport);
            };
            _this._publishViewportModes();
        });
        focusServiceProvider.sessionFocusEvent.addEventListener(function () {
            _this._publishViewportModes();
        });
    }
    ViewServiceProvider.prototype.sendUIEventToSession = function (uievent, session) {
        session.send('ar.view.uievent', uievent);
    };
    ViewServiceProvider.prototype._publishViewportModes = function () {
        this.sessionService.manager.send('ar.view.viewportMode', {
            mode: this.sessionViewportMode.get(this.sessionService.manager)
        });
        for (var _i = 0, _a = this.sessionService.managedSessions; _i < _a.length; _i++) {
            var session = _a[_i];
            var mode = (session === this.focusServiceProvider.session) ?
                this.sessionViewportMode.get(session) : 1 /* IMMERSIVE */;
            if (session.version[0] > 0)
                session.send('ar.view.viewportMode', { mode: mode });
        }
    };
    return ViewServiceProvider;
}());
ViewServiceProvider = __decorate([
    autoinject(),
    __metadata("design:paramtypes", [SessionService,
        ViewService,
        FocusServiceProvider,
        VisibilityServiceProvider])
], ViewServiceProvider);
export { ViewServiceProvider };
// setup our DOM environment
if (typeof document !== 'undefined' && document.createElement) {
    var viewportMetaTag = document.querySelector('meta[name=viewport]');
    if (!viewportMetaTag)
        viewportMetaTag = document.createElement('meta');
    viewportMetaTag.name = 'viewport';
    viewportMetaTag.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0';
    document.head.appendChild(viewportMetaTag);
    var argonMetaTag = document.querySelector('meta[name=argon]');
    if (!argonMetaTag)
        argonMetaTag = document.createElement('meta');
    argonMetaTag.name = 'argon';
    document.head.appendChild(argonMetaTag);
    var style = document.createElement("style");
    style.type = 'text/css';
    document.head.insertBefore(style, document.head.firstChild);
    var sheet = style.sheet;
    sheet.insertRule("\n        #argon {\n            position: fixed;\n            width: 100%;\n            height: 100%;\n            left: 0;\n            bottom: 0;\n            margin: 0;\n            border: 0;\n            padding: 0;\n        }\n    ", sheet.cssRules.length);
    sheet.insertRule("\n        .argon-view {\n            -webkit-tap-highlight-color: transparent;\n            -webkit-user-select: none;\n            user-select: none;\n        }\n    ", sheet.cssRules.length);
    sheet.insertRule("\n        .argon-immersive .argon-view {\n            position: fixed !important;\n            width: 100% !important;\n            height: 100% !important;\n            max-width: 100% !important;\n            max-height: 100% !important;\n            left: 0;\n            bottom: 0;\n            margin: 0;\n            border: 0;\n            padding: 0;\n            visibility: visible;\n        }\n    ", sheet.cssRules.length);
    sheet.insertRule("\n        .argon-immersive body {\n            visibility: hidden;\n        }\n    ", sheet.cssRules.length);
    sheet.insertRule("\n        .argon-interactive {\n            pointer-events: auto;\n        }\n    ", sheet.cssRules.length);
}
